---
sidebar_position: 3
description: C# sample code
---

# .NET (C#)

The sample code repository contains .NET projects that can be used as a reference to implement the Swift APIs in C#.

## OpenAPI Code Generator

The API clients and JSON models are generated using [NSwag.ApiDescription.Client](https://github.com/RicoSuter/NSwag) package.
The `OpenAPiReference` is configured in the `.csproj` file and the generated code is placed in the `MessagingApi.Generated` namespace.

:::info
API client for other API products can be generated as well using the OpenAPI Generator package. Change the `<Include>` property to point to the desired file to generate the code for another API product.
:::

```xml title="src/MessagingApi.csproj"
<OpenApiReference Include=".\SWIFT-API-Swift-Messaging-1.1.0-resolved.yaml">
    <Namespace>MessagingApi.Generated</Namespace>
    <ClassName>MessagingApiClient</ClassName>
    <OutputPath>MessagingApiClient.cs</OutputPath>
    <Options>/UseBaseUrl:false</Options>
</OpenApiReference>
```

## OAuth 2.0 Client

The lifecycle of the token is managed by a HTTP Client handler that automatically refreshes the token when it expires.

```csharp title="src/Handlers/AuthorizationClientHandler.cs"
public class AuthorizationClientHandler : DelegatingHandler
{
    private readonly OAuthTokenService _oAuthTokenService;

    public AuthorizationClientHandler(OAuthTokenService oAuthTokenService)
    {
        _oAuthTokenService = oAuthTokenService;
    }

    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var accessToken = await _oAuthTokenService.GetAccessToken();
        request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
        return await base.SendAsync(request, cancellationToken);
    }
}
```

When a new access token is required, the JWT token is created using the `Microsoft.IdentityModel` library
and a `POST` request as described in [OAuth Authentication](/consumer/security/oauth-authentication#token-request) guide is sent to retrieve the access token.

```csharp title="src/Services/OAuthTokenService.cs"
public async Task<string> GetAccessToken() {
    var assertion = CreateJwt(); // Implemented in the next method
    var parameters = new Dictionary<string, string>
    {
        ["grant_type"] = _settings.GrantType,
        ["scope"] = _settings.Scope,
        ["assertion"] = assertion
    };

    var httpRequestMessage = new HttpRequestMessage(HttpMethod.Post, _settings.TokenUri)
    {
        Content = new FormUrlEncodedContent(parameters)
    };

    var httpResponseMessage = _oauthHttpClient.Send(httpRequestMessage);
    // Parser the JSON response to get the access token
}

private string CreateJwt() {
    // Get certificate from keystore
    X509Certificate2 signingCert = new X509Certificate2(_settings.KeyStore, _settings.KeyStorePassword);
    var exportedCertificate = Convert.ToBase64String(signingCert.Export(X509ContentType.Cert), Base64FormattingOptions.None);

    // Private key used for signing
    var key = new RsaSecurityKey(signingCert.GetRSAPrivateKey());

    var audience = new Uri(_oauthHttpClient.BaseAddress!, _settings.TokenUri).ToString().Replace("https://", "");
    var now = DateTime.UtcNow;

    // Build the JWT
    var descriptor = new SecurityTokenDescriptor
    {
        TokenType = "JWT",
        Issuer = _consumerKey,
        Audience = audience,
        IssuedAt = now,
        NotBefore = now,
        Expires = now.AddSeconds(15),
        Claims = new Dictionary<string, object>()
        {
            [JwtRegisteredClaimNames.Jti] = Guid.NewGuid().ToString()
        },
        Subject = new ClaimsIdentity(new[] { new Claim(JwtRegisteredClaimNames.Sub, signingCert.Subject) }),
        AdditionalHeaderClaims = new Dictionary<string, object>()
        {
            [JwtHeaderParameterNames.X5c] = new List<string> { exportedCertificate }
        },
        SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSha256),
    };

    var handler = new JsonWebTokenHandler();
    var signedJwt = handler.CreateToken(descriptor);
}
```

## Swift signature

To create the signature, `SignatureClientHandler` HTTP handler is used.
The handler first removes the empty signature header (generated by the OpenAPI code generator) and then creates a new signature based on the request URI and request body
using the `SignatureService` service.

```csharp title="src/Handlers/SignatureClientHandler.cs"
public class SignatureClientHandler : DelegatingHandler
{
    private readonly string SignatureHeader = "X-SWIFT-Signature";

    private readonly SignatureService _signatureService;

    public SignatureClientHandler(SignatureService signatureService)
    {
        _signatureService = signatureService;
    }

    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        if (request.Headers.Contains(SignatureHeader) && request.Content != null)
        {
            request.Headers.Remove(SignatureHeader); // Remove empty signature
            var jws = _signatureService.CreateSign(request.RequestUri!.AbsoluteUri, await request.Content.ReadAsByteArrayAsync());
            request.Headers.Add(SignatureHeader, jws);
        }

        return await base.SendAsync(request, cancellationToken);
    }
}
```

```csharp title="src/Services/SignatureService.cs"
// Calculate digest from body and encode it in Base64
var base64 = Convert.ToBase64String(body);
string digestBase64;
using (SHA256 sha256Hash = SHA256.Create())
{
    byte[] digest = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(base64));
    digestBase64 = Convert.ToBase64String(digest);
}

// Get certificate from keystore
X509Certificate2 signingCert = new X509Certificate2(_settings.KeyStore, _settings.KeyStorePassword);
var exportedCertificate = Convert.ToBase64String(signingCert.Export(X509ContentType.Cert), Base64FormattingOptions.None);

// Private key used for signing
var key = new RsaSecurityKey(signingCert.GetRSAPrivateKey());
        
var now = DateTime.UtcNow;
var descriptor = new SecurityTokenDescriptor
{
    TokenType = "JWT",
    Audience = url.Replace("https://", ""),
    IssuedAt = now,
    NotBefore = now,
    Expires = now.AddSeconds(15),
    Claims = new Dictionary<string, object>()
    {
        [JwtRegisteredClaimNames.Jti.ToString()] = Guid.NewGuid().ToString(),
        ["digest"] = digestBase64
    },
    Subject = new ClaimsIdentity(new[] { new Claim(JwtRegisteredClaimNames.Sub, signingCert.Subject) }),
    AdditionalHeaderClaims = new Dictionary<string, object>()
    {
        [JwtHeaderParameterNames.X5c] = new List<string> { exportedCertificate }
    },
    SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSha256)
};
        
var handler = new JsonWebTokenHandler();
var signedJwt = handler.CreateToken(descriptor);
```
